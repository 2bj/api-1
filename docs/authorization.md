# Авторизация

Авторизация осуществляется по протоколу OAuth 2.0. Подробная документация по протоколу:
[RFC 6749](http://tools.ietf.org/html/rfc6749).

Зарегистрированное приложение может запрашивать у пользователей hh.ru разрешение доступа к их персональным данным, без
получения и хранения их логина и пароля.

---

В начале приложению необходимо направить пользователя (открыть страницу) по адресу:

```
https://m.hh.ru/oauth/authorize?response_type=code&client_id={client_id}&state={state}
```

В параметрах к запросу необходимо указать `client_id`, полученный при регистрации приложения.

Параметр `state` опционален, в случае его указания, он будет включен в ответный редирект — это позволяет исключить
возможность взлома путём подделки межсайтовых запросов. Подробнее об этом:
[RFC 6749. Section 10.12](http://tools.ietf.org/html/rfc6749#section-10.12)

Если пользователь не авторизован на сайте, ему будет показана форма авторизации на сайте.
После прохождения авторизации на сайте, пользователю будет выведена форма с запросом разрешения доступа вашего
приложения к его персональным данным.

Если пользователь не разрешает доступ приложению, пользователь будет перенаправлен на указанный `redirect_uri` с
`?error=access_denied` и `state={state}`, если таковой был указан при первом запросе.

В случае разрешения прав, в редиректе будет указан временный `authorization_code`:
```http
HTTP/1.1 302 FOUND
Location: {redirect_uri}?code={authorization_code}
```

Если пользователь авторизован на сайте и доступ данному приложению однажды ранее выдан, ответом будет сразу
вышеописаннный редирект с `authorization_code` (без показа формы логина и выдачи прав).

---

После получения `AUTH_CODE` приложению необходимо сделать сервер-сервер POST-запрос на
`https://m.hh.ru/oauth/token` для обмена полученного `authorization_code` на `access_token`.
В запросе необходимо передать:

```
grant_type=authorization_code&client_id={client_id}&client_secret={client_secret}&code={authorization_code}
```

Тело запроса необходимо передавать в стандартном `application/x-www-form-urlencoded` с указанием соответствующего
заголовка `Content-Type`.
        
Ответ:

```json
{
  "access_token": "{access_token}",
  "token_type": "bearer",
  "refresh_token": "{refresh_token}",
  "expires_in": 1209600
}
```

`authorization_code` имеет довольно короткий срок жизни, при его истечении необходимо запросить новый.
`expires_in` указан в секундах.

---

Приложение использует полученный `access_token` для авторизации, передавая его в заголовке. Для тестирования
токена, удобно использовать метод `/me`.

```http
GET /me HTTP/1.1
User-Agent: MyApp/1.0 (my-app-feedback@example.com)
Host: api.hh.ru
Accept: */*
Authorization: Bearer ACCESS_TOKEN
```

Документация по ответу от `/me` [в соответствующем разделе](me.md).

`access_token` имеет срок жизни, при его истечении приложение делает запрос с `refresh_token` для получения нового.
Запрос необходимо делать в `application/x-www-form-urlencoded` по аналогии с пунктом 4.

```
POST https://m.hh.ru/oauth/token
grant_type=refresh_token&refresh_token={refresh_token}
```

## Запрос авторизации под другим пользователем

Возможен следующий сценарий:

1. Приложение перенаправляет пользователя на сайт с запросом авторизации.
2. Пользователь на сайте уже авторизован и данному приложение доступ уже был разрешен.
3. В ответ сразу приходит перенаправление (redirect) со временным токеном и приложение получает по нему `access_token`.

В этом случае, автоматически выдаётся доступ пользователю авторизованному на сайте. Если необходимо запросить доступ
другого пользователя, приложение может добавить к запросу `/oauth/authorize...` параметр `force_login=true`. В этом
случае, пользователю будет показана форма авторизации с логином и паролем даже в случае, если пользователь уже
авторизован.

Это может быть полезно приложениям, которые предоставляют сервис только для соискателей. Если пришел
пользователь-работодатель, приложение может предложить пользователю повторно разрешить доступ на сайте, уже указав
другую учетную запись.

Также, после авторизации приложение может показать пользователю сообщение:
```
Вы вошли как %Имя_Фамилия%. Это не вы?
```
и предоставить ссылку с `force_login=true` для возможности захода под другим логином.

## Полезные ссылки

* Подробная документация по протоколу: [RFC 6749](http://tools.ietf.org/html/rfc6749)
